/**
 * AuthContext.tsx
 * 
 * This file now uses the modular auth context structure located in the auth/ directory.
 * It re-exports the components and hooks to maintain backward compatibility with
 * existing code that imports from this file.
 * 
 * The original functionality has been split into multiple files:
 * - auth/types.ts: Type definitions
 * - auth/AuthContext.ts: Context definition
 * - auth/AuthProvider.tsx: Provider component
 * - auth/userAuthService.ts: User authentication functions
 * - auth/adminService.ts: Admin operations
 * - auth/qrCodeService.ts: QR code generation
 * - auth/index.ts: Re-exports everything
 */

// Import and re-export from the modular structure
export { AuthProvider, useAuth } from "./auth";

// Export types if needed elsewhere
export { UserProfile, AdminProfile, AuthContextType, Lab, Subject, EnrolledLabInfo } from "./auth/types";


// Define types for better clarity
interface Subject {
  id: string;
  name: string;
  code: string;
}

interface Lab {
  id: string;
  name: string;
  section: string | null;
  day_of_week: string;
  start_time: string;
  end_time: string;
  subject_id: string;
  subjects: Subject | Subject[] | null; // Adjust based on actual Supabase return type
}

interface EnrolledLabInfo {
  labId: string;
  lab: Lab | null;
}

interface AuthContextType {
  isAuthenticated: boolean;
  isLoading: boolean;
  user: any;
  userProfile: UserProfile | null;
  adminProfile: AdminProfile | null;
  isAdmin: boolean;
  login: (email: string, password: string) => Promise<boolean>;
  adminLogin: (email: string, password: string) => Promise<boolean>;
  logout: () => void;
  register: (
    email: string,
    password: string,
    fullName: string,
    studentId: string,
    course?: string,
    section?: string
  ) => Promise<boolean>;
  updateProfile: (profileData: Partial<UserProfile>) => Promise<boolean>;
  refreshUserProfile: () => Promise<void>;
  getQRCode: () => Promise<string | null>;
  getAdminQRCode: () => Promise<string | null>;
  getAllStudents: () => Promise<any[]>;
  getAllLabs: () => Promise<any[]>;
  createLab: (labData: any) => Promise<boolean>;
  assignStudentToLab: (studentId: string, labId: string) => Promise<boolean>;
  removeStudentFromLab: (studentId: string, labId: string) => Promise<boolean>;
}

interface RegisterData {
  fullName: string;
  email: string;
  studentId: string;
  password: string;
  course?: string;
  section?: string;
}

// Use environment variable for API URL with more robust fallback
const API_URL =
  process.env.EXPO_PUBLIC_API_URL ||
  (Platform.OS === "android"
    ? "http://10.0.2.2:5000/api"
    : "http://localhost:5000/api");

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [user, setUser] = useState<any>(null);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  const [adminProfile, setAdminProfile] = useState<AdminProfile | null>(null);
  const [isAdmin, setIsAdmin] = useState(false);

  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      setIsLoading(true);
      // First check if we have a stored session
      const storedSession = await AsyncStorage.getItem("session");
      const storedUser = await AsyncStorage.getItem("user");
      const storedProfile = await AsyncStorage.getItem("userProfile");
      
      // Check for stored admin data
      const storedAdminProfile = await AsyncStorage.getItem("adminProfile");
      const storedIsAdmin = await AsyncStorage.getItem("isAdmin");
      
      // Set admin status if available
      if (storedIsAdmin === "true") {
        console.log("Restoring admin status from storage");
        setIsAdmin(true);
        
        if (storedAdminProfile) {
          try {
            const adminProfileData = JSON.parse(storedAdminProfile);
            setAdminProfile(adminProfileData)s;
            console.log(`Admin profile restored: ${adminProfileData.full_name}`);
          } catch (parseError) {
            console.error("Error parsing admin profile:", parseError);
          }
        }
      }

      if (storedSession && storedUser) {
        // We have stored credentials, let's restore the session
        const userData = JSON.parse(storedUser);
        setUser(userData);
        setIsAuthenticated(true);

        if (storedProfile) {
          setUserProfile(JSON.parse(storedProfile));
        } else {
          // If we have user but no profile, try to fetch it
          await fetchUserProfile(userData.id);
        }

        // Also verify with Supabase that the session is still valid
        const {
          data: { session },
        } = await supabase.auth.getSession();

        if (!session) {
          // If Supabase session is invalid, we need to refresh or log in again
          console.log("Stored session expired, attempting to refresh");
          const { error } = await supabase.auth.refreshSession();

          if (error) {
            console.error("Unable to refresh session:", error);
            // Force logout as the session is invalid
            await logout();
            return;
          }
        }
      } else {
        // Check if Supabase has a valid session
        const {
          data: { session },
        } = await supabase.auth.getSession();

        if (session) {
          setIsAuthenticated(true);
          setUser(session.user);
          await fetchUserProfile(session.user.id);

          // Store the session for future app launches
          await AsyncStorage.setItem("user", JSON.stringify(session.user));
          await AsyncStorage.setItem("session", JSON.stringify(session));
        } else {
          // No valid session found and not admin, reset state
          if (!storedIsAdmin) {
            setIsAuthenticated(false);
            setUser(null);
            setUserProfile(null);
          }
        }
      }
      
      // Log auth state for debugging
      console.log(`Auth check complete - isAdmin: ${isAdmin}, isAuthenticated: ${isAuthenticated}`);
      
    } catch (error) {
      console.error("Auth check error:", error);
      // If there's an error during auth check, reset to logged out state
      setIsAuthenticated(false);
      setUser(null);
      setUserProfile(null);
      setIsAdmin(false);
      setAdminProfile(null);
    } finally {
      setIsLoading(false);
    }
  };

  // Effect to detect and set admin status whenever user or profiles change
  useEffect(() => {
    const checkAdminStatus = () => {
      // Admin roles that should have admin privileges
      const adminRoles = ['admin', 'super_admin', 'faculty_admin'];
      
      // Check user metadata for admin roles
      const userMetadataRole = user?.user_metadata?.role;
      const appMetadataRole = user?.app_metadata?.role;
      
      // Check profiles for admin roles
      const userProfileRole = userProfile?.role;
      const adminProfileRole = adminProfile?.role;
      
      // Log all the role information we have for debugging
      console.log('Checking admin status with roles:', {
        userMetadataRole,
        appMetadataRole,
        userProfileRole,
        adminProfileRole,
        userId: user?.id,
        userEmail: user?.email
      });
      
      // Check if any role is an admin role
      if (
        adminRoles.includes(userMetadataRole) || 
        adminRoles.includes(appMetadataRole) || 
        adminRoles.includes(userProfileRole) || 
        adminRoles.includes(adminProfileRole)
      ) {
        console.log('Admin role detected, setting isAdmin = true');
        setIsAdmin(true);
        return true;
      }
      
      // Special check for faculty email patterns if no explicit role is found
      const email = user?.email;
      if (email && typeof email === 'string' && !email.includes('@swiftpass.edu')) {
        // Faculty accounts typically don't have @swiftpass.edu domain
        const potentialFacultyPattern = /^[a-z]\.[a-z]+$/i;  // pattern like d.abesamis
        if (potentialFacultyPattern.test(email)) {
          console.log('Faculty email pattern detected, setting isAdmin = true');
          setIsAdmin(true);
          return true;
        }
      }
      
      // Also check if user ID starts with "faculty-" which indicates a faculty admin
      const userId = user?.id;
      if (userId && typeof userId === 'string' && userId.startsWith('faculty-')) {
        console.log('Faculty user ID pattern detected, setting isAdmin = true');
        setIsAdmin(true);
        return true;
      }
      
      return false;
    };
    
    // Run the check if we have a user
    if (user) {
      checkAdminStatus();
    }
  }, [user, userProfile, adminProfile]);
  
  const fetchUserProfile = async (userId: string) => {
    try {
      console.log("Fetching user profile for userId:", userId);

      // First, check if this is an admin user
      const { data: adminData, error: adminError } = await supabase
        .from("admins")
        .select("*")
        .eq("id", userId)
        .single();

      if (adminData) {
        console.log("Admin profile found:", adminData);
        setAdminProfile(adminData);
        setIsAdmin(true);
        await AsyncStorage.setItem("adminProfile", JSON.stringify(adminData));
        await AsyncStorage.setItem("isAdmin", "true");
        return;
      }

      // If not an admin, fetch student profile
      const response = await UserProfileService.getUserProfile(userId);

      if (response.success && response.data) {
        console.log("User profile fetched successfully:", {
          id: response.data.id,
          email: response.data.email,
          full_name: response.data.full_name,
          student_id: response.data.student_id,
          course: response.data.course,
        });

        // Get the student's lab schedule
        const { data: enrollments, error: enrollmentError } = await supabase
          .from("student_labs")
          .select(
            `
            lab_id,
            labs!student_labs_lab_id_fkey (
              id, name, section, day_of_week, start_time, end_time,
              subjects:subject_id (
                id, name, code
              )
            )
          `
          )
          .eq("student_id", userId);

        if (!enrollmentError && enrollments) {
          // Process lab schedules by day
          const labSchedule: Record<string, any[]> = {};

          // Debug log information about enrollments
          console.log(
            `Found ${enrollments.length} lab enrollments for user ${userId}`
          );

          // If no specific enrollments found, let's fetch all labs that match the course and section
          if (enrollments.length === 0 && response.data?.course) {
            console.log(
              "No explicit lab enrollments, fetching labs by course and section"
            );

            // First, find matching subjects for the course
            const { data: subjects } = await supabase
              .from("subjects")
              .select("id, name, code");

            if (subjects && subjects.length > 0) {
              const studentCourse = response.data.course;
              const studentSection = response.data.section || "";

              // Find subjects that match the course
              const matchingSubjects = subjects.filter((subject: any) => {
                if (!subject || typeof subject !== "object") return false;

                const subjectName = subject.name || "";
                const subjectCode = subject.code || "";

                return (
                  subjectName
                    .toUpperCase()
                    .includes(studentCourse.toUpperCase()) ||
                  (subjectCode &&
                    studentCourse
                      .toUpperCase()
                      .includes(subjectCode.toUpperCase())) ||
                  (subjectCode &&
                    subjectCode
                      .toUpperCase()
                      .includes(studentCourse.toUpperCase()))
                );
              });

              console.log(
                `Found ${matchingSubjects.length} matching subjects for course: ${studentCourse}`
              );

              if (matchingSubjects.length > 0) {
                const subjectIds = matchingSubjects.map((s) => s.id);

                // Find all labs for these subjects
                const { data: matchingLabs } = await supabase
                  .from("labs")
                  .select(
                    `
                    id, name, section, day_of_week, start_time, end_time,
                    subjects:subject_id (
                      id, name, code
                    )
                  `
                  )
                  .in("subject_id", subjectIds);

                if (matchingLabs && matchingLabs.length > 0) {
                  console.log(
                    `Found ${matchingLabs.length} labs for matching subjects`
                  );

                  // Filter labs by section if specified
                  let filteredLabs = matchingLabs;
                  if (studentSection) {
                    const exactSectionMatch = matchingLabs.filter(
                      (lab) => lab.section === studentSection
                    );

                    if (exactSectionMatch.length > 0) {
                      filteredLabs = exactSectionMatch;
                      console.log(
                        `Found ${exactSectionMatch.length} labs with exact section match: ${studentSection}`
                      );
                    }
                  }

                  // Process labs into schedule
                  filteredLabs.forEach((lab) => {
                    if (!lab.day_of_week) return;

                    // Safely access subject data, assuming it might be an array
                    const subject = Array.isArray(lab.subjects)
                      ? lab.subjects[0]
                      : lab.subjects;

                    const day = lab.day_of_week;
                    if (!labSchedule[day]) {
                      labSchedule[day] = [];
                    }

                    labSchedule[day].push({
                      name: lab.name,
                      section: lab.section,
                      start_time: lab.start_time,
                      end_time: lab.end_time,
                      subject: subject?.name || "",
                      subject_code: subject?.code || "",
                    });
                  });

                  console.log(
                    `Processed lab schedule for ${
                      Object.keys(labSchedule).length
                    } days`
                  );
                } else {
                  console.log("No matching labs found for subjects");
                }
              }
            }
          } else {
            // Process each enrollment
            enrollments.forEach((enrollment: any) => {
              // Get the lab from the enrollment
              const lab = enrollment.labs;

              // Skip null/undefined labs
              if (!lab) return;

              // Safely access subject data, assuming it might be an array
              const subject = Array.isArray(lab.subjects)
                ? lab.subjects[0]
                : lab.subjects;
              if (!subject) return;

              // Check if student's course and section match the lab's subject and section
              const studentCourse = response.data?.course || "";
              const studentSection = response.data?.section || "";
              const labSubject = subject.name || "";
              const labSection = lab.section || "";

              // Improved course matching logic
              const courseMatches =
                !studentCourse ||
                labSubject
                  .toUpperCase()
                  .includes(studentCourse.toUpperCase()) ||
                (subject.code &&
                  studentCourse
                    .toUpperCase()
                    .includes(subject.code.toUpperCase())) ||
                (subject.code &&
                  subject.code
                    .toUpperCase()
                    .includes(studentCourse.toUpperCase()));

              // Section matching - either no section specified, or sections match
              const sectionMatches =
                !studentSection || labSection === studentSection;

              if (!courseMatches || !sectionMatches) {
                return; // Skip this lab
              }

              const day = lab.day_of_week;
              if (!labSchedule[day]) {
                labSchedule[day] = [];
              }

              labSchedule[day].push({
                name: lab.name,
                section: lab.section,
                start_time: lab.start_time,
                end_time: lab.end_time,
                subject: subject.name || "",
                subject_code: subject.code || "",
              });
            });
          }

          // Add lab schedule to user profile
          if (response.data) {
            response.data.lab_schedule = labSchedule;
            console.log(
              "Final lab schedule added to user profile:",
              Object.keys(labSchedule)
            );
          }
        }

        setUserProfile(response.data);
        setIsAdmin(false);
        await AsyncStorage.setItem(
          "userProfile",
          JSON.stringify(response.data)
        );
        await AsyncStorage.setItem("isAdmin", "false");
      } else {
        console.warn("Failed to fetch user profile:", response.error);
      }
    } catch (error) {
      console.error("Profile fetch error:", error);
    }
  };

  const login = async (email: string, password: string) => {
    try {
      setIsLoading(true);

      const response = await AuthService.login(email, password);

      if (!response.success) {
        throw new Error(response.error || "Login failed");
      }

      // Store session and user data
      await Promise.all([
        AsyncStorage.setItem("user", JSON.stringify(response.data.user)),
        AsyncStorage.setItem("session", JSON.stringify(response.data.session)),
      ]);

      setUser(response.data.user);
      setIsAuthenticated(true);
      await fetchUserProfile(response.data.user.id);

      // Route based on user role
      if (isAdmin) {
        router.replace("/admin" as any);
      } else {
        router.replace("/(tabs)/dashboard");
      }

      return true;
    } catch (error: unknown) {
      console.error("Login error:", error);

      if (error instanceof Error) {
        if (error.message.includes("Network request failed")) {
          Alert.alert(
            "Connection Error",
            "Unable to connect to the authentication server. Please check your internet connection and try again."
          );
        } else {
          Alert.alert("Login Error", error.message);
        }
      } else {
        Alert.alert("Error", "An unexpected error occurred during login");
      }
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    try {
      setIsLoading(true);

      const response = await AuthService.logout();

      if (!response.success) {
        throw new Error(response.error || "Logout failed");
      }

      // Clear all user states
      setIsAuthenticated(false);
      setUser(null);
      setUserProfile(null);
      
      // Also clear admin states
      setIsAdmin(false);
      setAdminProfile(null);

      // Remove all stored user data
      await AsyncStorage.removeItem("user");
      await AsyncStorage.removeItem("userProfile");
      await AsyncStorage.removeItem("session");
      
      // Remove admin-specific data
      await AsyncStorage.removeItem("adminProfile");
      await AsyncStorage.removeItem("isAdmin");
      
      console.log("Logout successful - all user and admin data cleared");

      router.replace("/login");
      return true;
    } catch (error: any) {
      console.error("Logout error:", error);
      Alert.alert("Logout Error", error.message || "Failed to logout");
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const register = async (
    email: string,
    password: string,
    fullName: string,
    studentId: string,
    course?: string,
    section?: string
  ) => {
    try {
      setIsLoading(true);

      console.log("Registering user:", {
        email,
        fullName,
        studentId,
        course,
        section,
      });

      // Use Supabase registration as primary method
      const response = await AuthService.register({
        email,
        password,
        fullName,
        studentId,
        course,
        section,
      });

      if (response.success) {
        setUser(response.data.user);
        setIsAuthenticated(true);

        // After successful registration and user creation
        await fetchUserProfile(response.data.user.id);

        // Generate and store QR code data for the user
        // This happens only once at registration time
        await createUserQRCode(
          response.data.user.id,
          fullName,
          studentId,
          course,
          section
        );

        await AsyncStorage.setItem("user", JSON.stringify(response.data.user));
        await AsyncStorage.setItem(
          "session",
          JSON.stringify(response.data.session)
        );

        router.replace("/login");
        return true;
      } else {
        // If Supabase registration fails with a specific error, show it
        throw new Error(response.error || "Registration failed");
      }
    } catch (error: unknown) {
      console.error("Registration error:", error);
      if (error instanceof Error) {
        if (error.message.includes("Network request failed")) {
          Alert.alert(
            "Connection Error",
            "Unable to connect to the authentication server. Please check your internet connection and try again."
          );
        } else {
          Alert.alert("Registration Error", error.message);
        }
      } else {
        Alert.alert(
          "Error",
          "An unexpected error occurred during registration"
        );
      }
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  // Create a QR code entry for the new user - only happens once at registration
  const createUserQRCode = async (
    userId: string,
    fullName: string,
    studentId: string,
    course?: string,
    section?: string
  ): Promise<boolean> => {
    try {
      console.log("Creating QR code for user:", userId);
      console.log(`Course: ${course}, Section: ${section}`);

      // Get current time information
      const now = new Date();
      const currentTime = now.toTimeString().split(" ")[0];
      const dayOfWeek = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
      ][now.getDay()];

      // Get current lab information if the student has course and section
      let currentLab = null;
      if (course && section) {
        // Find labs that match this student's course and section for today
        const { data: subjectData, error: subjectError } = await supabase
          .from("subjects")
          .select("id")
          .ilike("name", `%${course}%`);

        if (!subjectError && subjectData && subjectData.length > 0) {
          const subjectIds = subjectData.map((subject) => subject.id);

          // Try with exact section match first
          const { data: labData } = await supabase
            .from("labs")
            .select("*")
            .in("subject_id", subjectIds)
            .eq("section", section)
            .eq("day_of_week", dayOfWeek);

          // If no labs with exact section, try without section filter
          if (!labData || labData.length === 0) {
            const { data: allLabData } = await supabase
              .from("labs")
              .select("*")
              .in("subject_id", subjectIds)
              .eq("day_of_week", dayOfWeek);

            if (allLabData && allLabData.length > 0) {
              // Find if there's a lab right now
              const currentLabs = allLabData.filter((lab) => {
                const labStartTime = lab.start_time;
                const labEndTime = lab.end_time;
                return currentTime >= labStartTime && currentTime <= labEndTime;
              });

              if (currentLabs.length > 0) {
                currentLab = currentLabs[0];
              }
            }
          } else if (labData && labData.length > 0) {
            // Find if there's a lab right now
            const currentLabs = labData.filter((lab) => {
              const labStartTime = lab.start_time;
              const labEndTime = lab.end_time;
              return currentTime >= labStartTime && currentTime <= labEndTime;
            });

            if (currentLabs.length > 0) {
              currentLab = currentLabs[0];
            }
          }
        }
      }

      // Create QR code data with enhanced information
      const qrData = {
        userId: userId,
        studentId: studentId,
        name: fullName,
        course: course || "Not Specified",
        section: section || "Not Specified",
        timestamp: now.toISOString(),
        currentDay: dayOfWeek,
        currentTime: currentTime,
        currentLab: currentLab
          ? {
              name: currentLab.name,
              time: `${currentLab.start_time} - ${currentLab.end_time}`,
              day: currentLab.day_of_week,
            }
          : null,
      };

      // Insert the QR code data into the qr_codes table
      const { error } = await supabase.from("qr_codes").insert([
        {
          student_id: userId,
          qr_data: qrData,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        },
      ]);

      if (error) {
        console.error("Error creating QR code:", error);
        return false;
      }

      console.log("QR code created successfully for user:", userId);
      return true;
    } catch (error) {
      console.error("Failed to create QR code:", error);
      return false;
    }
  };

  const refreshUserProfile = async () => {
    if (user) {
      await fetchUserProfile(user.id);
      // After fetching profile, auto-assign to labs if needed
      if (userProfile && !isAdmin) {
        await autoAssignToLabs(
          user.id,
          userProfile.course,
          userProfile.section
        );
      }
    }
  };

  // Automatically assign student to labs matching their course and section
  const autoAssignToLabs = async (
    studentId: string,
    course?: string,
    section?: string
  ) => {
    try {
      if (!course) {
        console.log("Skipping auto lab assignment - missing course");
        return false;
      }

      console.log(`Auto-assigning labs for student: ${studentId}`);
      console.log(`Course: ${course}, Section: ${section || "Not specified"}`);

      // First check if student already has lab assignments
      const { data: existingAssignments, error: assignmentsError } =
        await supabase
          .from("student_labs")
          .select("*")
          .eq("student_id", studentId);

      if (assignmentsError) {
        console.error(
          "Error checking existing lab assignments:",
          assignmentsError
        );
        return false;
      }

      // If student already has assignments, don't add more
      if (existingAssignments && existingAssignments.length > 0) {
        console.log(
          `Student already has ${existingAssignments.length} lab assignments. Skipping auto-assignment.`
        );
        return true;
      }

      // Find subject IDs for the student's course
      const { data: subjectData, error: subjectError } = await supabase
        .from("subjects")
        .select("id")
        .ilike("name", `%${course}%`);

      if (subjectError || !subjectData || subjectData.length === 0) {
        console.error(
          "Error finding subject for course:",
          subjectError || "No subjects found"
        );
        return false;
      }

      const subjectIds = subjectData.map((subject) => subject.id);
      console.log(`Found ${subjectIds.length} matching subjects`);

      let matchingLabs;

      // If section is provided, try with exact section match first
      if (section) {
        // Find all labs matching the subject and exact section
        const { data: sectionLabs, error: labsError } = await supabase
          .from("labs")
          .select("id")
          .in("subject_id", subjectIds)
          .eq("section", section);

        if (labsError) {
          console.error("Error finding matching labs:", labsError);
          return false;
        }

        if (sectionLabs && sectionLabs.length > 0) {
          matchingLabs = sectionLabs;
          console.log(
            `Found ${matchingLabs.length} labs matching exact section`
          );
        }
      }

      // If no labs found with exact section match or no section provided,
      // get all labs for the subject
      if (!matchingLabs || matchingLabs.length === 0) {
        const { data: allSubjectLabs, error: subjectLabsError } = await supabase
          .from("labs")
          .select("id")
          .in("subject_id", subjectIds);

        if (subjectLabsError) {
          console.error("Error finding subject labs:", subjectLabsError);
          return false;
        }

        if (allSubjectLabs && allSubjectLabs.length > 0) {
          matchingLabs = allSubjectLabs;
          console.log(
            `Found ${allSubjectLabs.length} labs matching subject without section filter`
          );
        } else {
          console.log("No labs found for this subject");
          return false;
        }
      }

      // Assign student to matching labs
      const assignments = matchingLabs.map((lab) => ({
        student_id: studentId,
        lab_id: lab.id,
        created_at: new Date().toISOString(),
      }));

      const { error: insertError } = await supabase
        .from("student_labs")
        .insert(assignments);

      if (insertError) {
        console.error("Error assigning labs:", insertError);
        return false;
      }

      console.log(`Auto-assigned student to ${assignments.length} labs`);
      return true;
    } catch (error) {
      console.error("Error in auto lab assignment:", error);
      return false;
    }
  };

  const getQRCode = async () => {
    try {
      if (!user) {
        console.error("Error: You need to be logged in to get a QR code");
        return null;
      }

      // Get current time information
      const now = new Date();
      const currentTime = now.toTimeString().split(" ")[0]; // HH:MM:SS format
      const dayOfWeek = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
      ][now.getDay()];

      // Get current lab information and enrollments
      let currentLab: EnrolledLabInfo | null = null;
      let enrolledLabs: EnrolledLabInfo[] = [];

      // First get student's lab enrollments
      const { data: enrollments, error: enrollmentError } = await supabase
        .from("student_labs")
        .select(
          `
          lab_id,
          labs!student_labs_lab_id_fkey (
            id, name, section, day_of_week, start_time, end_time,
            subjects:subject_id (
              id, name, code
            )
          )
        `
        )
        .eq("student_id", user.id);

      if (!enrollmentError && enrollments && enrollments.length > 0) {
        // Store all labs the student is enrolled in
        enrolledLabs = enrollments
          .map((enrollment: any): EnrolledLabInfo | null => {
            // Assuming `enrollment.labs` might be null or even an array based on previous errors
            const labData = Array.isArray(enrollment.labs)
              ? enrollment.labs[0]
              : enrollment.labs;
            return labData
              ? { labId: enrollment.lab_id, lab: labData as Lab }
              : null;
          })
          .filter(
            (item): item is EnrolledLabInfo =>
              item !== null && item.lab !== null
          );

        // Find if there's a current lab session today
        const todayLabs = enrolledLabs.filter(
          (item) => item.lab?.day_of_week === dayOfWeek
        );

        if (todayLabs.length > 0) {
          // Find if any of today's labs are happening right now
          const currentLabs = todayLabs.filter((item) => {
            if (!item.lab) return false;
            const labStartTime = item.lab.start_time;
            const labEndTime = item.lab.end_time;
            return currentTime >= labStartTime && currentTime <= labEndTime;
          });

          if (currentLabs.length > 0) {
            currentLab = currentLabs[0];
          }
        }
      } else if (userProfile?.course && userProfile?.section) {
        // Fallback: If no enrollments found, try to find labs that match this student's course and section for today
        const { data: subjectData, error: subjectError } = await supabase
          .from("subjects")
          .select("id")
          .ilike("name", `%${userProfile.course}%`);

        if (!subjectError && subjectData && subjectData.length > 0) {
          const subjectIds = subjectData.map((subject) => subject.id);

          // Try to find labs matching exact section first
          const { data: labData } = await supabase
            .from("labs")
            .select("*")
            .in("subject_id", subjectIds)
            .eq("section", userProfile.section)
            .eq("day_of_week", dayOfWeek);

          // If no exact section match, try without section filter
          if (!labData || labData.length === 0) {
            const { data: allLabData } = await supabase
              .from("labs")
              .select("*")
              .in("subject_id", subjectIds)
              .eq("day_of_week", dayOfWeek);

            if (allLabData && allLabData.length > 0) {
              // Find if there's a lab right now
              const currentLabs = allLabData.filter((lab) => {
                const labStartTime = lab.start_time;
                const labEndTime = lab.end_time;
                return currentTime >= labStartTime && currentTime <= labEndTime;
              });

              if (currentLabs.length > 0) {
                currentLab = {
                  labId: currentLabs[0].id,
                  lab: currentLabs[0],
                };
              }
            }
          } else if (labData && labData.length > 0) {
            // Find if there's a lab right now with exact section match
            const currentLabs = labData.filter((lab) => {
              const labStartTime = lab.start_time;
              const labEndTime = lab.end_time;
              return currentTime >= labStartTime && currentTime <= labEndTime;
            });

            if (currentLabs.length > 0) {
              currentLab = {
                labId: currentLabs[0].id,
                lab: currentLabs[0],
              };
            }
          }
        }
      }

      // First check if user has a QR code in the database
      const { data: qrCodeData, error: qrError }: { data: { qr_data: any } | null, error: { code: string, message: string } | null } = await supabase
        .from("qr_codes")
        .select("qr_data")
        .eq("student_id", user.id)
        .single();

      if (qrError) {
        // If no QR code exists, create one (this should only happen for existing accounts before this update)
        if (qrError.code === "PGRST116" && userProfile) {
          // No QR code found, create a new permanent one
          const success = await createUserQRCode(
            user.id,
            userProfile.full_name,
            userProfile.student_id,
            userProfile.course,
            userProfile.section
          );

          if (success) {
            // Try to get the newly created QR code
            const { data: newQrRecord, error: newQrError } = await supabase
              .from("qr_codes")
              .select("qr_data")
              .eq("student_id", user.id)
              .single();

            if (newQrError) {
              throw new Error("Failed to retrieve newly created QR code");
            }

            // Update with current time and lab info
            const updatedQrDataBase = {
              timestamp: now.toISOString(),
              currentDay: dayOfWeek,
              currentTime: currentTime,
              studentId: user.id,
              labId: currentLab ? currentLab.labId : null,
              currentLab: currentLab?.lab
                ? {
                    id: currentLab.labId,
                    name: currentLab.lab.name,
                    time: `${currentLab.lab.start_time} - ${currentLab.lab.end_time}`,
                    day: currentLab.lab.day_of_week,
                  }
                : null,
              enrolledLabs: enrolledLabs.map((item) => ({
                id: item.labId,
                name: item.lab?.name || "Unknown Lab",
                day: item.lab?.day_of_week || "Unknown Day",
                time: item.lab
                  ? `${item.lab.start_time} - ${item.lab.end_time}`
                  : "Unknown Time",
              })),
            };

            let finalQrData: any = {};

            if (qrError) {
              // Handle creation of new QR code
              if (qrError.code === "PGRST116" && userProfile) {
                const success = await createUserQRCode(
                  user.id,
                  userProfile.full_name,
                  userProfile.student_id,
                  userProfile.course,
                  userProfile.section
                );
                if (success) {
                  const { data: newQrData, error: newQrError } = await supabase
                    .from("qr_codes")
                    .select("qr_data")
                    .eq("student_id", user.id)
                    .single();
                  if (newQrError)
                    throw new Error("Failed to retrieve newly created QR code");

                  // Safely access qr_data from the fetched record
                  const baseData =
                    newQrData &&
                    typeof newQrData.qr_data === "object" &&
                    newQrData.qr_data !== null
                      ? newQrData.qr_data
                      : {};
                  finalQrData = { ...baseData, ...updatedQrDataBase };

                  await supabase
                    .from("qr_codes")
                    .update({
                      qr_data: finalQrData,
                      updated_at: now.toISOString(),
                    })
                    .eq("student_id", user.id);
                } else {
                  throw new Error("Failed to create QR code");
                }
              } else {
                throw new Error("Error retrieving QR code: " + qrError.message);
              }
            } else {
              // Update existing QR code data
              // Safely access qr_data from the existing record
              const baseData =
                qrCodeData &&
                typeof qrCodeData.qr_data === "object" &&
                qrCodeData.qr_data !== null
                  ? qrCodeData.qr_data
                  : {};
              finalQrData = { ...baseData, ...updatedQrDataBase };

              await supabase
                .from("qr_codes")
                .update({
                  qr_data: finalQrData,
                  updated_at: now.toISOString(),
                })
                .eq("student_id", user.id);
            }

            // Return the user's updated QR code data
            return JSON.stringify(finalQrData);
          } else {
            throw new Error("Failed to create QR code");
          }
        } else {
          throw new Error("Error retrieving QR code: " + qrError.message);
        }
      }

      // Update the existing QR code with current time and lab info
      const updatedQrDataBase = {
        timestamp: now.toISOString(),
        currentDay: dayOfWeek,
        currentTime: currentTime,
        studentId: user.id,
        labId: currentLab ? currentLab.labId : null,
        currentLab: currentLab?.lab
          ? {
              id: currentLab.labId,
              name: currentLab.lab.name,
              time: `${currentLab.lab.start_time} - ${currentLab.lab.end_time}`,
              day: currentLab.lab.day_of_week,
            }
          : null,
        enrolledLabs: enrolledLabs.map((item) => ({
          id: item.labId,
          name: item.lab?.name || "Unknown Lab",
          day: item.lab?.day_of_week || "Unknown Day",
          time: item.lab
            ? `${item.lab.start_time} - ${item.lab.end_time}`
            : "Unknown Time",
        })),
      };

      let finalQrData: any = {};

      if (qrError) {
        // Handle creation of new QR code
        if ((qrError as { code: string }).code === "PGRST116" && userProfile) {
          const success = await createUserQRCode(
            user.id,
            userProfile.full_name,
            userProfile.student_id,
            userProfile.course,
            userProfile.section
          );
          if (success) {
            // Refetch the QR code data after creation
            const { data: newQrRecord, error: newQrError } = await supabase
              .from("qr_codes")
              .select("qr_data")
              .eq("student_id", user.id)
              .single();

            if (newQrError)
              throw new Error("Failed to retrieve newly created QR code");

            // Safely access qr_data from the fetched record
            const baseData =
              newQrRecord &&
              typeof newQrRecord.qr_data === "object" &&
              newQrRecord.qr_data !== null
                ? newQrRecord.qr_data
                : {};
            finalQrData = { ...baseData, ...updatedQrDataBase };

            await supabase
              .from("qr_codes")
              .update({
                qr_data: finalQrData,
                updated_at: now.toISOString(),
              })
              .eq("student_id", user.id);
          } else {
            throw new Error("Failed to create QR code");
          }
        } else {
          throw new Error("Error retrieving QR code: " + qrError.message);
        }
      } else {
        // Update existing QR code data
        // Safely access qr_data from the existing record
        const baseData =
          qrCodeData &&
          typeof qrCodeData.qr_data === "object" &&
          qrCodeData.qr_data !== null
            ? qrCodeData.qr_data
            : {};
        finalQrData = { ...baseData, ...updatedQrDataBase };

        await supabase
          .from("qr_codes")
          .update({
            qr_data: finalQrData,
            updated_at: now.toISOString(),
          })
          .eq("student_id", user.id);
      }

      // Return the user's updated QR code data
      return JSON.stringify(finalQrData);
    } catch (error: unknown) {
      console.error("QR code error:", error);

      // Type guard for Supabase errors or generic errors
      let errorMessage = "An unexpected QR code error occurred";
      if (error && typeof error === "object") {
        if ("message" in error) {
          errorMessage = String(error.message);
        }
        if ("code" in error && error.code === "PGRST116") {
          // Handle specific Supabase error if needed, otherwise log generic message
          console.warn(
            "Supabase specific error PGRST116 occurred, but handled in logic above."
          );
        }
      }

      console.error(`QR Code Fetch/Update Failed: ${errorMessage}`);

      // Only log to console, don't show alert to user
      // Generate fallback QR code for the user if possible
      if (userProfile) {
        // Get current time information for fallback
        const now = new Date();
        const currentTime = now.toTimeString().split(" ")[0];
        const dayOfWeek = [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ][now.getDay()];

        const fallbackQrData = {
          userId: user?.id,
          studentId: userProfile.student_id,
          name: userProfile.full_name,
          course: userProfile.course || "Not Specified",
          section: userProfile.section || "Not Specified",
          timestamp: now.toISOString(),
          currentDay: dayOfWeek,
          currentTime: currentTime,
          generated: "fallback",
          // Ensure fallback doesn't rely on potentially null currentLab
          labId: null,
          currentLab: null,
          enrolledLabs: [],
        };
        return JSON.stringify(fallbackQrData);
      }

      return null;
    }
  };

  // Admin login with multiple faculty accounts
  const adminLogin = async (email: string, password: string) => {
    try {
      setIsLoading(true);

      // Define faculty admin accounts
      const facultyAccounts = [
        // Super admin account
        {
          username: "admin@swiftpass.edu",
          password: "Admin123!",
          fullName: "System Administrator",
          role: "super_admin"
        },
        // Faculty accounts
        {
          username: "d.abesamis",
          password: "Abes@2025Dr!",
          fullName: "Dr. Dennis B Abesamis",
          role: "faculty_admin"
        },
        {
          username: "m.reyes",
          password: "Reyes@2025En!",
          fullName: "Engr. Maria Joy Reyes",
          role: "faculty_admin"
        },
        {
          username: "a.zantua",
          password: "Zantua@2025En!",
          fullName: "Engr. Apollo Zantua",
          role: "faculty_admin"
        },
        {
          username: "r.general",
          password: "General@2025En!",
          fullName: "Engr. Rico General",
          role: "faculty_admin"
        },
        {
          username: "f.morallo",
          password: "Morallo@2025En!",
          fullName: "Engr. Fenwill Morallo",
          role: "faculty_admin"
        },
        {
          username: "j.villarino",
          password: "Villarino@25En!",
          fullName: "Engr. John Renor Villarino",
          role: "faculty_admin"
        },
        {
          username: "c.aston",
          password: "Aston@2025En!",
          fullName: "Engr. Carmen Aston",
          role: "faculty_admin"
        },
        {
          username: "m.basilio",
          password: "Basilio@2025Ms!",
          fullName: "Mrs. Mary Ann Basilio",
          role: "faculty_admin"
        },
        {
          username: "e.pepito",
          password: "Pepito@2025Dr!\\",
          fullName: "Dr. Esterlina Pepito",
          role: "faculty_admin"
        }
      ];

      // Find the matching account
      const adminAccount = facultyAccounts.find(
        account => {
          // Match either username directly or email for backward compatibility
          const usernameMatch = account.username === email;
          const emailMatch = account.username.includes('@') ? 
            account.username === email : 
            `${account.username}@swiftpass.edu` === email;
          
          return (usernameMatch || emailMatch) && account.password === password;
        }
      );

      if (adminAccount) {
        console.log(`Admin login: ${adminAccount.fullName}`);

        try {
          // First try normal login in case account is already in Supabase
          const emailToUse = adminAccount.username.includes('@') 
            ? adminAccount.username 
            : `${adminAccount.username}@swiftpass.edu`;
            
          const { data, error } = await supabase.auth.signInWithPassword({
            email: emailToUse,
            password: adminAccount.password,
          });

          if (!error && data && data.user) {
            console.log("Admin login successful via normal auth flow");

            // Store session and user data
            await Promise.all([
              AsyncStorage.setItem("user", JSON.stringify(data.user)),
              AsyncStorage.setItem("session", JSON.stringify(data.session)),
            ]);

            setUser(data.user);
            setIsAuthenticated(true);
            await fetchUserProfile(data.user.id);

            router.replace("/admin" as any);
            return true;
          }

          // If normal login failed, create special admin session
          console.log("Creating special admin session");

          // Generate consistent unique ID for this admin
          const adminId = adminAccount.username === "admin@swiftpass.edu" 
            ? "admin-special-id" 
            : `faculty-${adminAccount.username}`;
          
          // Create admin user object
          const adminUser = {
            id: adminId,
            email: emailToUse,
            user_metadata: {
              full_name: adminAccount.fullName,
              role: adminAccount.role,
            },
            app_metadata: {
              role: adminAccount.role,
            },
          };

          // Create admin profile
          const profile = {
            id: adminId,
            email: emailToUse,
            full_name: adminAccount.fullName,
            role: adminAccount.role,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          };

          // Set authentication state
          await AsyncStorage.setItem("user", JSON.stringify(adminUser));
          await AsyncStorage.setItem("adminProfile", JSON.stringify(profile));
          await AsyncStorage.setItem("isAdmin", "true");

          // Set local state
          setUser(adminUser);
          setAdminProfile(profile);
          setIsAdmin(true);
          setIsAuthenticated(true);

          // Navigate to admin dashboard
          router.replace("/admin" as any);
          return true;
        } catch (error) {
          console.error("Admin login flow failed:", error);
          throw new Error("Admin login failed");
        }
      } else {
        throw new Error("Invalid admin credentials");
      }
    } catch (error: unknown) {
      console.error("Admin login error:", error);

      if (error instanceof Error) {
        Alert.alert("Admin Login Error", error.message);
      } else {
        Alert.alert("Error", "An unexpected error occurred during admin login");
      }
      return false;
    } finally {
      setIsLoading(false);
    }
  };
  
  // Admin functions
  const getAllStudents = async () => {
    try {
      if (!isAdmin) {
        throw new Error("Unauthorized access");
      }

      const { data, error } = await supabase
        .from("students")
        .select("*")
        .order("created_at", { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error("Error fetching students:", error);
      return [];
    }
  };

  const getAllLabs = async () => {
    try {
      const { data, error } = await supabase
        .from("labs")
        .select(
          `
          *,
          subjects(name, code)
        `
        )
        .order("day_of_week", { ascending: true });

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error("Error fetching labs:", error);
      return [];
    }
  };

  const createLab = async (labData: any) => {
    try {
      if (!isAdmin) {
        throw new Error("Unauthorized access");
      }

      const { error } = await supabase.from("labs").insert([labData]);

      if (error) throw error;
      return true;
    } catch (error) {
      console.error("Error creating lab:", error);
      return false;
    }
  };

  const assignStudentToLab = async (studentId: string, labId: string) => {
    try {
      if (!isAdmin) {
        throw new Error("Unauthorized access");
      }

      const { error } = await supabase.from("student_labs").insert([
        {
          student_id: studentId,
          lab_id: labId,
          created_at: new Date().toISOString(),
        },
      ]);

      if (error) throw error;
      return true;
    } catch (error) {
      console.error("Error assigning student to lab:", error);
      return false;
    }
  };

  const removeStudentFromLab = async (studentId: string, labId: string) => {
    try {
      if (!isAdmin) {
        throw new Error("Unauthorized access");
      }

      const { error } = await supabase.from("student_labs").delete().match({
        student_id: studentId,
        lab_id: labId,
      });

      if (error) throw error;
      return true;
    } catch (error) {
      console.error("Error removing student from lab:", error);
      return false;
    }
  };

    // Generate a special admin QR code that bypasses schedule checks
  const getAdminQRCode = async (): Promise<string | null> => {
    try {
      // Log current state for debugging
      console.log("Debug - getAdminQRCode state:", {
        userExists: !!user,
        userId: user?.id,
        userEmail: user?.email,
        isAdmin,
        adminProfile,
        role: adminProfile?.role || user?.user_metadata?.role || user?.app_metadata?.role
      });
      
      // Check if user is faculty admin based on role in metadata or adminProfile
      const isFacultyAdmin = 
        (user?.user_metadata?.role === "faculty_admin") || 
        (user?.app_metadata?.role === "faculty_admin") || 
        (adminProfile?.role === "faculty_admin");
      
      // Allow both system admins and faculty admins to generate QR codes
      if (!user || (!isAdmin && !isFacultyAdmin)) {
        console.error("Error: Only admins can generate admin QR codes");
        return null;
      }

      // Create admin information
      const now = new Date();
      
      // Check if the user ID is a valid UUID format
      const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      const isValidUuid = typeof user.id === 'string' && uuidPattern.test(user.id);
      
      // For faculty users with non-UUID IDs, we'll skip database operations
      // and return a memory-only QR code that still has the admin_override flag
      if (!isValidUuid) {
        console.log(`Faculty admin detected with non-UUID ID: ${user.id}. Generating in-memory QR code.`);
        
        // Create a memory-only admin QR code with all the necessary data
        const inMemoryQrData = {
          userId: user.id,
          name: adminProfile?.full_name || "Administrator",
          role: adminProfile?.role || "admin",
          email: user.email,
          timestamp: now.toISOString(),
          is_admin: true,
          admin_override: true,     // Special flag to bypass schedule checks
          privilege_level: 100,     // High privilege level for admins
          expiry: new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString(), // 24 hour validity
          generated_at: now.toISOString(),
          generated_type: "memory-only",  // Indicate this wasn't stored in the database
        };
        
        console.log("Generated in-memory admin QR code successfully");
        return JSON.stringify(inMemoryQrData);
      }
      
      // For regular admin accounts with valid UUIDs, proceed with database operations
      console.log(`Admin with valid UUID: ${user.id}. Proceeding with database operations.`);
      
      // Create the QR code data for storage in the database
      const adminData = {
        userId: user.id,
        name: adminProfile?.full_name || "Administrator",
        role: adminProfile?.role || "admin",
        email: user.email,
        timestamp: now.toISOString(),
        is_admin: true,
        admin_override: true,     // Special flag to bypass schedule checks
        privilege_level: 100,     // High privilege level for admins
        expiry: new Date(now.getTime() + 24 * 60 * 60 * 1000).toISOString(), // 24 hour validity
        generated_at: now.toISOString(),
      };
      
      // Check if admin already has a QR code
      const { data: existingQrCode, error: qrError } = await supabase
        .from("qr_codes")
        .select("*")
        .eq("student_id", user.id)
        .maybeSingle();
      
      // Handle any query errors
      if (qrError && qrError.code !== "PGRST116") {
        console.error("Error checking for existing QR code:", qrError);
        // In case of database error, return the in-memory code
        console.log("Database error. Falling back to in-memory QR code.");
        return JSON.stringify(adminData);
      }
      
      // Update or create the QR code
      if (existingQrCode) {
        console.log("Updating existing admin QR code");
        
        const { error: updateError } = await supabase
          .from("qr_codes")
          .update({
            qr_data: adminData,
            updated_at: now.toISOString(),
          })
          .eq("id", existingQrCode.id);
          
        if (updateError) {
          console.error("Error updating QR code:", updateError);
          // Even if update fails, return the QR code data
          return JSON.stringify(adminData);
        }
      } else {
        console.log("Creating new admin QR code");
        
        // IMPORTANT: Only create new QR code entry for admin with valid UUID
        // that matches an existing student_id in the students table
        const { error: insertError } = await supabase.from("qr_codes").insert([
          {
            student_id: user.id,  // Use the actual user ID which should exist in students table
            qr_data: adminData,
            created_at: now.toISOString(),
            updated_at: now.toISOString(),
          },
        ]);
        
        if (insertError) {
          console.error("Error creating QR code:", insertError);
          // If insert fails, still return the QR code data for immediate use
          console.log("Database insert failed. Using in-memory QR code instead.");
          return JSON.stringify(adminData);
        }
      }
      
      // Return the serialized QR code data regardless of database operation success
      console.log("Successfully generated admin QR code");
      return JSON.stringify(adminData);
    } catch (error) {
      console.error("Admin QR code generation error:", error);
      
      // Last resort fallback - create a basic admin QR code in memory
      if (user && isAdmin) {
        const fallbackData = {
          userId: user.id,
          name: adminProfile?.full_name || "Administrator",
          email: user.email,
          timestamp: new Date().toISOString(),
          is_admin: true,
          admin_override: true,
          privilege_level: 100,
          expiry: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
          generated_type: "fallback",
        };
        console.log("Generated fallback admin QR code");
        return JSON.stringify(fallbackData);
      }
      
      return null;
    }
  };


  // Update user profile
  const updateProfile = async (profileData: Partial<UserProfile>): Promise<boolean> => {
    try {
      if (!user?.id) {
        throw new Error('User not authenticated');
      }
      
      setIsLoading(true);
      
      // Only update fields that are provided
      const updates: any = {};
      if (profileData.full_name) updates.full_name = profileData.full_name;
      if (profileData.student_id) updates.student_id = profileData.student_id;
      if ('course' in profileData) updates.course = profileData.course;
      if ('section' in profileData) updates.section = profileData.section;
      if ('phone_number' in profileData) updates.phone_number = profileData.phone_number;
      if ('address' in profileData) updates.address = profileData.address;
      if ('emergency_contact' in profileData) updates.emergency_contact = profileData.emergency_contact;
      if ('bio' in profileData) updates.bio = profileData.bio;
      
      updates.updated_at = new Date().toISOString();
      
      // Update in Supabase
      const { error } = await supabase
        .from('students')
        .update(updates)
        .eq('id', user.id);
        
      if (error) throw error;
      
      // Also try to update Express backend if available
      try {
        const response = await fetch(`${API_URL}/profile/update`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            userId: user.id,
            ...updates
          }),
        });
        
        if (!response.ok) {
          console.warn('Express backend profile update failed, but Supabase update succeeded');
        }
      } catch (expressError) {
        console.warn('Express backend unavailable for profile update:', expressError);
      }
      
      // Update local state and storage
      await refreshUserProfile();
      
      return true;
    } catch (error) {
      console.error('Error updating profile:', error);
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const contextValue: AuthContextType = {
    isAuthenticated,
    isLoading,
    user,
    userProfile,
    adminProfile,
    isAdmin,
    login,
    adminLogin,
    logout,
    register,
    updateProfile,
    refreshUserProfile,
    getQRCode,
    getAdminQRCode,
    getAllStudents,
    getAllLabs,
    createLab,
    assignStudentToLab,
    removeStudentFromLab,
  };

  return (
    <AuthContext.Provider value={contextValue}>{children}</AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};

